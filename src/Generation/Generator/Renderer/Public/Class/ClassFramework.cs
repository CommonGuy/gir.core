using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Model;

namespace Generator.Renderer.Public;

internal static class ClassFramework
{
    public static string Render(GirModel.Class cls)
    {
        var @sealed = cls.Final ? "sealed " : string.Empty;

        return $@"
using System;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace {Namespace.GetPublicName(cls.Namespace)};

// AUTOGENERATED FILE - DO NOT MODIFY

{PlatformSupportAttribute.Render(cls as GirModel.PlatformDependent)}
[GObject.Handle<{Class.GetFullyQualifiedInternalHandleName(cls)}>]
public {@sealed}partial class {cls.Name}({Class.GetFullyQualifiedInternalHandleName(cls)} handle) {RenderInheritance(cls)}
{{
    {RenderPublicConstructor(cls)}
}}";
    }

    private static string RenderInheritance(GirModel.Class cls)
    {
        var parentClass = cls.Parent is null ? null : $"{ComplexType.GetFullyQualified(cls.Parent)}(handle)";
        var interfaces = cls.Implements.Select(ComplexType.GetFullyQualified);

        var elements = new List<string>(interfaces);

        if (parentClass is not null)
            elements.Insert(0, parentClass);

        return elements.Count == 0
            ? string.Empty
            : $": {string.Join(", ", elements)}";
    }

    private static string RenderPublicConstructor(GirModel.Class cls)
    {
        return cls.Final
            ? $"   public {cls.Name}(params GObject.ConstructArgument[] constructArguments) : this({Class.GetFullyQualifiedInternalHandleName(cls)}.Create(constructArguments)) {{ }}"
            : $"   public {cls.Name}(params GObject.ConstructArgument[] constructArguments) : this({Class.GetFullyQualifiedInternalHandleName(cls)}.For<{cls.Name}>(constructArguments)) {{ }}";
    }
}
