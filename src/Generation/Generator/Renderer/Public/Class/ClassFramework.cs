using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Model;

namespace Generator.Renderer.Public;

internal static class ClassFramework
{
    public static string Render(GirModel.Class cls)
    {
        var @sealed = cls.Final ? "sealed " : string.Empty;

        return $@"
using System;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace {Namespace.GetPublicName(cls.Namespace)};

// AUTOGENERATED FILE - DO NOT MODIFY

{PlatformSupportAttribute.Render(cls as GirModel.PlatformDependent)}
public {@sealed}partial class {cls.Name} {RenderInheritance(cls)}
{{
    {$"protected internal {cls.Name}({Class.GetFullyQualifiedInternalHandleName(cls)} handle) : base(handle) {{ }}"}
    {RenderPublicConstructor(cls)}
}}";
    }

    private static string RenderInheritance(GirModel.Class cls)
    {
        var parentClass = cls.Parent is null ? null : ComplexType.GetFullyQualified(cls.Parent);
        var interfaces = cls.Implements.Select(ComplexType.GetFullyQualified);

        var elements = new List<string>(interfaces);

        if (parentClass is not null)
            elements.Insert(0, parentClass);

        return elements.Count == 0
            ? string.Empty
            : $": {string.Join(", ", elements)}";
    }

    private static string RenderPublicConstructor(GirModel.Class cls)
    {
        var owned = Class.IsInitiallyUnowned(cls) ? "false" : "true";

        return cls.Final
            ? $"   public {cls.Name}() : this({Class.GetFullyQualifiedInternalHandleName(cls)}.Create({owned}, Array.Empty<GObject.ConstructArgument>())) {{ }}"
            : $"   public {cls.Name}() : this({Class.GetFullyQualifiedInternalHandleName(cls)}.For<{cls.Name}>({owned}, Array.Empty<GObject.ConstructArgument>())) {{ }}";
    }
}
